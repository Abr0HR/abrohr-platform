const ExcelJS = require('exceljs');
const PDFDocument = require('pdfkit');
const fs = require('fs').promises;
const path = require('path');
const { format } = require('date-fns');

class ReportGeneratorService {
  
  async generateExcelReport(reportData, outputPath) {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Report');
    
    // Title
    worksheet.mergeCells('A1', `${String.fromCharCode(64 + reportData.columns.length)}1`);
    const titleCell = worksheet.getCell('A1');
    titleCell.value = reportData.title;
    titleCell.font = { size: 16, bold: true, color: { argb: 'FF4F46E5' } };
    titleCell.alignment = { horizontal: 'center', vertical: 'middle' };
    titleCell.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E7FF' }
    };
    worksheet.getRow(1).height = 30;
    
    // Metadata
    worksheet.getCell('A2').value = `Generated: ${format(new Date(), 'PPpp')}`;
    worksheet.getCell('A2').font = { size: 9, italic: true };
    worksheet.getRow(3).values = []; // Empty row
    
    // Headers
    const headerRow = worksheet.addRow(reportData.columns);
    headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    headerRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF4F46E5' }
    };
    headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerRow.height = 25;
    
    // Add borders to headers
    headerRow.eachCell(cell => {
      cell.border = {
        top: { style: 'thin' },
        left: { style: 'thin' },
        bottom: { style: 'thin' },
        right: { style: 'thin' }
      };
    });
    
    // Data rows
    reportData.data.forEach((row, index) => {
      const dataRow = worksheet.addRow(Object.values(row));
      
      // Alternating row colors
      if (index % 2 === 0) {
        dataRow.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFF9FAFB' }
        };
      }
      
      // Add borders
      dataRow.eachCell(cell => {
        cell.border = {
          top: { style: 'thin', color: { argb: 'FFE5E7EB' } },
          left: { style: 'thin', color: { argb: 'FFE5E7EB' } },
          bottom: { style: 'thin', color: { argb: 'FFE5E7EB' } },
          right: { style: 'thin', color: { argb: 'FFE5E7EB' } }
        };
      });
    });
    
    // Auto-width columns
    worksheet.columns.forEach(column => {
      let maxLength = 10;
      column.eachCell({ includeEmpty: true }, cell => {
        const length = cell.value ? String(cell.value).length : 10;
        if (length > maxLength) maxLength = length;
      });
      column.width = Math.min(maxLength + 3, 50);
    });
    
    // Summary section if exists
    if (reportData.summary) {
      worksheet.addRow([]); // Empty row
      worksheet.addRow([]); // Empty row
      
      const summaryTitleRow = worksheet.addRow(['SUMMARY']);
      summaryTitleRow.font = { bold: true, size: 14, color: { argb: 'FF4F46E5' } };
      
      Object.entries(reportData.summary).forEach(([key, value]) => {
        const summaryRow = worksheet.addRow([key, value]);
        summaryRow.getCell(1).font = { bold: true };
      });
    }
    
    // Add footer
    const lastRow = worksheet.lastRow.number + 2;
    const footerCell = worksheet.getCell(`A${lastRow}`);
    footerCell.value = 'Generated by AbrO HR Platform - Theory-backed HR Intelligence';
    footerCell.font = { size: 8, italic: true, color: { argb: 'FF6B7280' } };
    
    await workbook.xlsx.writeFile(outputPath);
    return outputPath;
  }
  
  async generatePDFReport(reportData, outputPath) {
    return new Promise((resolve, reject) => {
      const doc = new PDFDocument({ 
        margin: 50,
        size: 'A4',
        bufferPages: true
      });
      const stream = require('fs').createWriteStream(outputPath);
      
      doc.pipe(stream);
      
      // Header with color
      doc.rect(0, 0, doc.page.width, 80).fill('#4F46E5');
      doc.fillColor('#FFFFFF')
         .fontSize(24)
         .text(reportData.title, 50, 25, { align: 'center' });
      
      // Metadata
      doc.fillColor('#E0E7FF')
         .fontSize(10)
         .text(`Generated: ${format(new Date(), 'PPpp')}`, 50, 55, { align: 'right' });
      
      doc.fillColor('#000000'); // Reset color
      
      // Move down after header
      doc.y = 100;
      
      // Table
      const tableTop = doc.y + 20;
      const columnWidth = (doc.page.width - 100) / reportData.columns.length;
      const rowHeight = 25;
      
      // Table headers
      doc.rect(50, tableTop, doc.page.width - 100, rowHeight)
         .fillAndStroke('#4F46E5', '#4F46E5');
      
      doc.fillColor('#FFFFFF').fontSize(10);
      reportData.columns.forEach((col, i) => {
        doc.text(
          col,
          50 + (i * columnWidth),
          tableTop + 7,
          { width: columnWidth, align: 'center' }
        );
      });
      
      // Table rows
      doc.fillColor('#000000');
      reportData.data.forEach((row, rowIndex) => {
        const y = tableTop + rowHeight + (rowIndex * rowHeight);
        
        // Check if we need a new page
        if (y > doc.page.height - 100) {
          doc.addPage();
          doc.y = 50;
          return;
        }
        
        // Alternating row colors
        if (rowIndex % 2 === 0) {
          doc.rect(50, y, doc.page.width - 100, rowHeight)
             .fill('#F9FAFB');
        }
        
        // Row data
        doc.fontSize(9).fillColor('#000000');
        Object.values(row).forEach((value, colIndex) => {
          doc.text(
            String(value),
            50 + (colIndex * columnWidth),
            y + 7,
            { width: columnWidth - 5, align: 'left' }
          );
        });
        
        // Row border
        doc.strokeColor('#E5E7EB')
           .lineWidth(0.5)
           .moveTo(50, y + rowHeight)
           .lineTo(doc.page.width - 50, y + rowHeight)
           .stroke();
      });
      
      // Summary if exists
      if (reportData.summary) {
        doc.moveDown(3);
        doc.fontSize(14).fillColor('#4F46E5').text('SUMMARY', { underline: true });
        doc.fontSize(10).fillColor('#000000').moveDown();
        
        Object.entries(reportData.summary).forEach(([key, value]) => {
          doc.text(`${key}: ${value}`, { indent: 20 });
        });
      }
      
      // Footer
      const pages = doc.bufferedPageRange();
      for (let i = 0; i < pages.count; i++) {
        doc.switchToPage(i);
        
        // Footer text
        doc.fontSize(8)
           .fillColor('#6B7280')
           .text(
             'Generated by AbrO HR Platform - Theory-backed HR Intelligence',
             50,
             doc.page.height - 50,
             { align: 'center' }
           );
        
        // Page numbers
        doc.text(
          `Page ${i + 1} of ${pages.count}`,
          50,
          doc.page.height - 35,
          { align: 'center' }
        );
      }
      
      doc.end();
      
      stream.on('finish', () => resolve(outputPath));
      stream.on('error', reject);
    });
  }
  
  async generateReport(reportData, format, outputDir) {
    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true });
    
    const timestamp = Date.now();
    const sanitizedTitle = reportData.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const filename = `${sanitizedTitle}_${timestamp}`;
    
    if (format === 'excel' || format === 'both') {
      const excelPath = path.join(outputDir, `${filename}.xlsx`);
      await this.generateExcelReport(reportData, excelPath);
    }
    
    if (format === 'pdf' || format === 'both') {
      const pdfPath = path.join(outputDir, `${filename}.pdf`);
      await this.generatePDFReport(reportData, pdfPath);
    }
    
    return {
      filename,
      excelPath: format === 'excel' || format === 'both' ? `${filename}.xlsx` : null,
      pdfPath: format === 'pdf' || format === 'both' ? `${filename}.pdf` : null
    };
  }
}

module.exports = new ReportGeneratorService();
